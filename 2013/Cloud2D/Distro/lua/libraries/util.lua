--[[	© 2011-2012 CloudSixteen.com do not share, re-distribute or modify	this file without the permission of its owner(s).
	Conna Wiles (connawiles@gmail.com)--]]util = {};util.m_images = {};util.m_rayData = {};util.m_textures = {};util.m_imagePaths = {};-- A function to convert a line to a key and value.function util.LineToKeyValue(lineData)	local exploded = string.Explode(":", lineData, nil, string.Trim);	local key, value = nil;		if (exploded[1]) then		key = exploded[1];	end;		if (exploded[2]) then		value = exploded[2];	end;		if (not key or not value) then		return key, value;	end;		local isString = string.GetBetweenTags(value, "\"");		if (isString) then		value = isString;	elseif (value == "true" or value == "false") then		value = util.ToBool(value);	else		local isArray = string.GetBetweenTags(value, "[", "]");				if (isArray) then			value = string.Explode(",", isArray, nil, tonumber);		else			value = tonumber(value);		end;	end;		return key, value;end;-- A function to convert key values to a table.function util.KeyValuesToTable(keyValues)	local bBlockComment = false;	local linesTable = string.Explode("\n", keyValues);	local retTable = {};	local block = retTable;		for k, v in ipairs(linesTable) do		if (string.sub(v, 0, 2) == "/*" and not bBlockComment) then			bBlockComment = true;		end;				if (not bBlockComment) then			local lineData = v;			local startPos, endPos = string.find(lineData, "//");						if (startPos and endPos) then				lineData = string.sub(lineData, 0, startPos - 1);			end;						if (lineData ~= "") then				local isCategory = string.GetBetweenTags(lineData, "{", "}");								if (isCategory) then					if (not retTable[isCategory]) then						retTable[isCategory] = {};					end;										block = retTable[isCategory];				else					local key, value = util.LineToKeyValue(lineData);										if (key and value) then						block[key] = value;					end;				end;			end;		end;				if (string.sub(v, 0, 2) == "*/" and bBlockComment) then			bBlockComment = false;		end;	end;		return retTable;end;-- A function to fix a file path (ported from C++).function util.FixFilePath(fileName, basePath, extension)	if (not files.Exists(fileName)) then		if (string.sub(fileName, 0, string.len(basePath)) ~= basePath) then			fileName = basePath..fileName;		end;				if (files.GetExt(fileName) == "") then			fileName = fileName..extension;		end;				return fileName;	else		return fileName;	end;end;-- A function to convert text to a boolean.function util.ToBool(text)	if (text == "true") then		return true;	elseif (text == "false") then		return false;	end;end;-- A function to get a random vector.function util.RandVector()	return Vec2(math.RandomFloat(-1, 1), math.RandomFloat(-1, 1));end;-- A function to add an accessor.function util.AddAccessor(classTable, friendlyName, keyName)	classTable["Set"..friendlyName] = function(classTable, value)		classTable[keyName] = value;	end;		classTable["Get"..friendlyName] = function(classTable)		return classTable[keyName];	end;end;-- A function to grab files in a directory.function util.GrabFilesInDir(directory, pattern, Callback)	if (not pattern) then pattern = "*"; end;		local fileList = {};		for k in files.Scan(directory, "*") do		if (not Callback or Callback(k)) then			fileList[#fileList + 1] = k;		end;	end;		return fileList;end;-- A function to transition between two values.function util.Transition(valFrom, valTo, timeToTake, timeLeft)	return valFrom + (((valTo - valFrom) / timeToTake) * (timeToTake - timeLeft));end;-- A function to get an image.function util.GetImage(fileName)	if (not util.m_images[fileName]) then		local imageObj = render.GetImage(fileName);		util.m_images[fileName] = imageObj;		util.m_imagePaths[imageObj] = fileName;	end;		return util.m_images[fileName];end;-- A function to get the image path from an object.function util.GetImagePath(imageObj)	return util.m_imagePaths[imageObj];end;-- A function to get a texture.function util.GetTexture(fileName)	if (not util.m_textures[fileName]) then		util.m_textures[fileName] = render.GetTexture(fileName);	end;		return util.m_textures[fileName];end;-- A function to get the mouse position.function util.GetMousePos()	return inputs.GetMousePos()end;-- A function to convert a screen position to a world position.function util.ScreenToWorld(position, bIgnoreBounds)	if (bIgnoreBounds or camera.IsInScreenBounds(position)) then		local cameraPos = camera.GetDrawPos();		return Vec2(cameraPos.x + position.x, cameraPos.y + position.y);	end;end;-- A function to convert an angle to a vector.function util.AngleToVector(angle)	if (type(angle) ~= "number") then		local radians = angle:Radians();		return Vec2(math.cos(radians), math.sin(radians));	else		return Vec2(math.cos(angle), math.sin(angle));	end;end;-- A function to normalize a vector.function util.NormalizeVector(vector)	local length = vector:Length();		return Vec2(		vector.x / length,		vector.y / length	);end;-- A function to get the angle between two vectors.function util.AngleBetweenVectors(vecOne, vecTwo)	return util.Radians(math.atan2(vecTwo.y - vecOne.y, vecTwo.x - vecOne.x));end;-- A function to get whether a vector is empty.function util.IsEmptyVector(vector)	return (vector.x == 0 and vector.y == 0);end;-- A function to get the size of some text.function util.GetTextSize(fontName, text)	return fonts.GetFont(fontName):GetTextSize(text);end;-- A function to make blood particles at a position.function util.MakeBloodParticles(position, color, scale)	if (not color) then color = Color(0.8, 0.1, 0.1, 0.7); end;	if (not scale) then scale = 1; end;		local emitter = emitters.New(position);		for i = 1, 8 do			local particle = emitter:Add("particles/simple", Vec2(0, 0));						particle:SetKillTime(math.random(1, 3));			particle:SetStartSize(math.random(16, 32) * scale);			particle:SetEndSize(math.random(8, 16) * scale);			particle:SetVelocity(util.RandVector() * math.random(64, 128));			particle:SetColor(color);		end;	emitter:Dispatch();end;-- A function to get the furthest vector.function util.GetFurthestVector(position, ...)	local positions = {...};	local furthest = {};		for k, v in ipairs(positions) do		local distance = v:Distance(position);				if (not furthest.vector or distance > furthest.distance) then			furthest.distance = distance;			furthest.vector = v;		end;	end;		return furthest.vector;end;-- A function to get the closest entity to another entity.function util.GetClosestEntity(entity, className, Condition)	local entityList = nil;		if (type(className) ~= "table") then		entityList = entities.GetByClassName(className);	else		entityList = className;	end;		local position = entity:GetCenter();	local closest = {};		for k, v in ipairs(entityList) do		if (entity ~= v and (not Condition or Condition(v))) then			local distance = v:GetCenter():Distance(position);						if (not closest.entity or distance < closest.distance) then				closest.distance = distance;				closest.entity = v;			end;		end;	end;		return closest.entity, closest.distance;end;-- A function to get the ray data.function util.GetTraceData()	return util.m_rayData;end;-- A function to perform cast a ray.function util.RayCast(startPos, endPos, filter, Condition)	if (type(filter) ~= "table") then		filter = {filter};	end;		util.m_rayData = {		Condition = Condition;		results = {			hitMaterial = MAT_GENERIC,			hitEntity = nil,			startPos = startPos,			distance = startPos:Distance(endPos),			fraction = 0,			endPos = endPos,			hitPos = endPos,			didHit = false		},		filter = filter;	};		physics.RayCast(startPos, endPos);		local results = util.m_rayData.results;		util.m_rayData = nil;	return results;end;-- A function to create a rectangle.function util.Rectangle(x, y, w, h)	return {		x = x,		y = y,		w = w,		h = h	};end;-- A function to snap a position to a grid.function util.SnapToGrid(position, gridSize)	if (type(position) ~= "number") then		return Vec2(			util.SnapToGrid(position.x, gridSize),			util.SnapToGrid(position.y, gridSize)		);	else		local dividedSize = position / gridSize;				if (math.abs(math.floor(dividedSize) - dividedSize)		< math.abs(math.ceil(dividedSize) - dividedSize)) then			return math.floor(position / gridSize) * gridSize;		else			return math.ceil(position / gridSize) * gridSize;		end;	end;end;-- A function to get the distance from a line to a position.function util.LineToPosDist(lineStart, lineEnd, position)	local m = lineEnd - lineStart;	local t = m:Dot(position - lineStart) / m:Dot(m);		return ( lineStart + (m * t) ):Distance(position)end;-- A function to get whether a position is inside a rectangle.function util.IsInside(rectangle, position)	return (position.x > rectangle.x and position.y > rectangle.y		and position.x < rectangle.x + rectangle.w		and position.y < rectangle.y + rectangle.h);end;-- A function to get whether a rectangle overlaps another rectangle.function util.DoesOverlap(rectangleA, rectangleB)	return (rectangleA.x + rectangleA.w > rectangleB.x		and rectangleA.y + rectangleA.h > rectangleB.y		and rectangleB.x + rectangleB.w > rectangleA.x		and rectangleB.y + rectangleB.h > rectangleA.y);end;-- A function to get the name of a file with no extension.function util.FileNameNoExt(fileName)	local extension = files.GetExt(fileName);		if (extension ~= "") then		return files.GetName(string.sub(fileName, 0, -(string.len(extension) + 2)));	else		return files.GetName(fileName);	end;end;-- A function to get whether a file name is an image.function util.IsImage(fileName)	local extension = files.GetExt(fileName);	return (extension == "png" or extension == "gif" or extension == "jpg");end;-- A function to get whether a file name is a directory.function util.IsDirectory(fileName)	if (string.sub(fileName, -1) == "/" or files.GetExt(fileName) == "") then		return true;	else		return false;	end;end;-- A function to get a new angle object in degrees.function util.Degrees(degrees)	return Angle(degrees, ANGLE_DEGREES);end;-- A function to get a new angle object in radians.function util.Radians(radians)	return Angle(radians, ANGLE_RADIANS);end;local KEYS = {	[KEY_NUMPAD0] = "0",	[KEY_NUMPAD1] = "1",	[KEY_NUMPAD2] = "2",	[KEY_NUMPAD3] = "3",	[KEY_NUMPAD4] = "4",	[KEY_NUMPAD5] = "5",	[KEY_NUMPAD6] = "6",	[KEY_NUMPAD7] = "7",	[KEY_NUMPAD8] = "8",	[KEY_NUMPAD9] = "9",	[KEY_MULTIPLY] = "*",	[KEY_ADD] = "+",	[KEY_SEPARATOR] = "_",	[KEY_SUBTRACT] = "-",	[KEY_DECIMAL] = ".",	[KEY_DIVIDE] = "/",	[KEY_SPACE] = " ",	[KEY_0] = "0",	[KEY_1] = "1",	[KEY_2] = "2",	[KEY_3] = "3",	[KEY_4] = "4",	[KEY_5] = "5",	[KEY_6] = "6",	[KEY_7] = "7",	[KEY_8] = "8",	[KEY_9] = "9",	[KEY_A] = "a",	[KEY_B] = "b",	[KEY_C] = "c",	[KEY_D] = "d",	[KEY_E] = "e",	[KEY_F] = "f",	[KEY_G] = "g",	[KEY_H] = "h",	[KEY_I] = "i",	[KEY_J] = "j",	[KEY_K] = "k",	[KEY_L] = "l",	[KEY_M] = "m",	[KEY_N] = "n",	[KEY_O] = "o",	[KEY_P] = "p",	[KEY_Q] = "q",	[KEY_R] = "r",	[KEY_S] = "s",	[KEY_T] = "t",	[KEY_U] = "u",	[KEY_V] = "v",	[KEY_W] = "w",	[KEY_X] = "x",	[KEY_Y] = "y",	[KEY_Z] = "z",	["\\"] = "\\",	[","] = ",",	["."] = ".",	["/"] = "/",	["'"] = "'",	[";"] = ";",	["]"] = "]",	["["] = "[",	["="] = "=",	["-"] = "-"};local CAPS = {	[KEY_0] = ")",	[KEY_1] = "!",	[KEY_2] = "\"",	[KEY_3] = "£",	[KEY_4] = "$",	[KEY_5] = "%",	[KEY_6] = "^",	[KEY_7] = "&",	[KEY_8] = "*",	[KEY_9] = "(",	[KEY_A] = "A",	[KEY_B] = "B",	[KEY_C] = "C",	[KEY_D] = "D",	[KEY_E] = "E",	[KEY_F] = "F",	[KEY_G] = "G",	[KEY_H] = "H",	[KEY_I] = "I",	[KEY_J] = "J",	[KEY_K] = "K",	[KEY_L] = "L",	[KEY_M] = "M",	[KEY_N] = "N",	[KEY_O] = "O",	[KEY_P] = "P",	[KEY_Q] = "Q",	[KEY_R] = "R",	[KEY_S] = "S",	[KEY_T] = "T",	[KEY_U] = "U",	[KEY_V] = "V",	[KEY_W] = "W",	[KEY_X] = "X",	[KEY_Y] = "Y",	[KEY_Z] = "Z",	["\\"] = "|",	[","] = "<",	["."] = ">",	["/"] = "?",	["'"] = "@",	[";"] = ":",	["]"] = "}",	["["] = "{",	["="] = "+",	["-"] = "_"};-- A function to get a friendly key name by ID.function util.GetKeyByID(key, bIsShift, bIsStr)	if (bIsShift and CAPS[key]) then		return CAPS[key];	elseif (KEYS[key]) then		return KEYS[key];	end;		if (not bIsStr) then		return util.GetKeyByID(inputs.GetKeyName(key), bIsShift, true);	end;end;