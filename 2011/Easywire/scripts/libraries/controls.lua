--[[	© 2011 CloudSixteen.com do not share, re-distribute or modify	this file without the permission of its owner(s).--]]controls = {};controls.m_memory = { key = {}, mouse = {} };controls.m_toolTip = nil;controls.m_focused = nil;controls.m_classes = {};controls.m_created = {};controls.m_deletion = {};-- A function to get the tool tip.function controls.GetToolTip()	if ( controls.m_toolTip and controls.m_toolTip:IsValid() ) then		return controls.m_toolTip;	end;end;-- A function to set the tool tip.function controls.SetToolTip(panel)	local toolTip = panel:GetToolTip();		if (toolTip and toolTip ~= "") then		if (not controls.m_toolTip) then			controls.m_toolTip = controls.Create("ToolTip");		end;				controls.m_toolTip:SetText(toolTip);		controls.m_toolTip:UpdatePosition();	end;end;-- A function to remove the tool tip.function controls.RemoveToolTip()	if (controls.m_toolTip) then		controls.m_toolTip:Remove();		controls.m_toolTip = nil;	end;end;-- A function to set the focused control.function controls.SetFocused(control)	if ( controls.m_focused and controls.m_focused:IsValid() ) then		controls.m_focused:OnLoseFocus();		controls.m_focused = nil;	end;		if ( control and control:IsValid() ) then		controls.m_focused = control;		controls.m_focused:OnGetFocus();	end;		hooks.Call("ControlFocusChange",		controls.m_focused	);end;-- A function to get the focused control.function controls.GetFocused()	if ( controls.m_focused and controls.m_focused:IsValid() ) then		return controls.m_focused;	end;end;-- A function to import an controlfunction controls.Import(fileName)	local className = util.FileNameNoExt(fileName);	local controlTable = controls.GetTable(className);		if (not controlTable) then		CONTROL = controls.New(className == "BaseControl");		CONTROL.m_sClassName = className;			g_Lua:LoadScript(fileName);		return controls.Register(CONTROL);	else		return controlTable;	end;end;-- A function to get a control table.function controls.GetTable(className)	return controls.m_classes[className];end;-- A function to create a new control.function controls.Create(className, parent, ...)	local control = controls.Derive(className);		control:__init( {...} );	control:SetParent(parent);			return control;end;-- A function to remove a control.function controls.Remove(control, bJustInvalid)	if ( control and control:IsValid() ) then		if (not bJustInvalid) then			controls.m_deletion[#controls.m_deletion + 1] = control;		end;				for k, v in ipairs( control:GetChildren() ) do			controls.Remove(v, true);		end;				control.m_bInvalid = true;	end;end;-- An internal function to remove a control's children.local function RemoveControlChildren(control)	local children = control:GetChildren();		for k, v in ipairs(children) do		if (controls.m_focused == v) then				controls.m_focused = nil;		end;				RemoveControlChildren(v);			table.remove(children, k);		v.m_bInvalid = true;				v:__remove();	end;end;-- An internal function to safely remove a control.local function SafeRemoveControl(control)	for k, v in ipairs(controls.m_created) do		if (v == control) then			table.remove(controls.m_created, k);			break;		end;	end;		local parent = control:GetParent();		if (parent) then		local children = parent:GetChildren();				for k, v in ipairs(children) do			if (v == control) then				table.remove(children, k);				break;			end;		end;	end;		if (controls.m_focused == control) then			controls.m_focused = nil;	end;		RemoveControlChildren(control);		control.m_bInvalid = true;	control:__remove();end;-- A function to clear the controls.function controls.Clear()	for k, v in ipairs(controls.m_created) do		if (controls.m_focused == v) then				controls.m_focused = nil;		end;				RemoveControlChildren(v);			table.remove(controls.m_created, k);		v:__remove();	end;		controls.m_deletion = {};	controls.m_focused = nil;	controls.m_memory = {		mouse = {},		key = {}	};end;-- A function to get the control at a specific position.function controls.GetAtPos(control, x, y, condition)	if (control) then		local allControls = control:GetChildren();				for i = #allControls, 1, -1 do			if ( allControls[i]:IsPosInside(x, y)			and allControls[i]:IsVisible() ) then				local childControl = controls.GetAtPos(					allControls[i], x, y, condition				);								if (childControl) then					return childControl;				end;			end;		end;				if ( not condition or condition(control)		and control:IsVisible() ) then			return control;		end;	else		local focused = controls.GetFocused();				if ( focused and not focused:GetParent()		and focused:IsPosInside(x, y) ) then			return controls.GetAtPos(focused, x, y, condition);		else			local allControls = controls.GetAll();						for i = #allControls, 1, -1 do				if ( allControls[i]:IsPosInside(x, y)				and allControls[i]:IsVisible() ) then					return controls.GetAtPos(						allControls[i], x, y, condition					);				end;			end;		end;	end;end;-- A function to handle input for the controls.function controls.HandleInput(inputType, ...)	local arguments = {...};	local focused = controls.GetFocused();		if (inputType == "MouseButtonRelease") then		local button = arguments[1];		local control = controls.m_memory.mouse[button];		local mousePos = util.GetMousePos();				if ( control and control:IsValid() ) then			control:OnMouseButtonRelease(button, mousePos.x, mousePos.y);				hooks.Call("ControlMouseButtonRelease", control, button);			controls.m_memory.mouse[button] = nil;						return true;		end;	elseif (inputType == "MouseButtonPress") then		local mousePos = util.GetMousePos();		local control = controls.GetAtPos(nil, mousePos.x, mousePos.y, function(panel)			return panel:GetClickable();		end);		local button = arguments[1];				hooks.Call("ControlMouseButtonPress", control, button);				if (control) then			controls.m_memory.mouse[button] = control;			control:OnMouseButtonPress(button, mousePos.x, mousePos.y);			control:SetFocused(true);						return true;		elseif (focused) then			focused:SetFocused(false);		end;	elseif (inputType == "KeyRelease") then		local key = arguments[1];				if ( controls.m_memory.key[key]		and controls.m_memory.key[key]:IsValid() ) then			controls.m_memory.key[key]:OnKeyRelease(key);			controls.m_memory.key[key] = nil;		end;	elseif (inputType == "KeyPress") then		local key = arguments[1];				if (focused) then			controls.m_memory.key[key] = focused;			focused:OnKeyPress(key);						return true;		end;	end;		return false;end;-- A function to update the controls.function controls.Update(deltaTime)	for k, v in ipairs(controls.m_deletion) do		table.remove(controls.m_deletion, k);		SafeRemoveControl(v);	end;		for k, v in ipairs(controls.m_created) do		if ( v:IsValid() ) then			v:CallHook("__update", deltaTime);		end;	end;		local mousePos = util.GetMousePos();	local control = controls.GetAtPos(nil, mousePos.x, mousePos.y, function(panel)		local toolTip = panel:GetToolTip();		return (toolTip and toolTip ~= "");	end);		if (control) then		controls.SetToolTip(control);	else		controls.RemoveToolTip();	end;end;-- A function to draw the controls.function controls.Draw()	local toolTip = controls.GetToolTip();		for k, v in ipairs(controls.m_created) do		if (v:IsValid() and not v:IsFocused()		and v ~= toolTip) then			v:CallHook("__draw");		end;	end;		local focused = controls.GetFocused();		if ( focused and not focused:GetParent() ) then		focused:CallHook("__draw");	end;		if (toolTip) then		toolTip:CallHook("__draw");	end;		hooks.Call("DrawControls");end;-- A function to get whether a control is valid.function controls.IsValid(control)	if ( control and type(control) == "table" and type(control.IsValid) == "function"	and control:IsValid() ) then		return true;	end;		return false;end;-- A function to get all created controls.function controls.GetAll()	return controls.m_created;end;-- A function to create a new control.function controls.New(bBaseObject)	if (not bBaseObject) then		local baseControl = controls.Import("controls/BaseControl");				if (baseControl) then			local object = {};				setmetatable(object, baseControl);				baseControl.__index = baseControl;			return object;		end;	else		return {};	end;end;-- A function to derive a control from its bases.function controls.Derive(className, baseClass)	local controlTable = controls.GetTable(className);		if (not controlTable) then return baseClass; end;		if (not baseClass) then		if (not controlTable.m_sBaseClass) then			return table.CreateCopy(controlTable);		else			baseClass = table.CreateCopy(controlTable);		end;	end;		if (controlTable.m_sBaseClass) then		controls.Derive(controlTable.m_sBaseClass, baseClass);	end;		table.MergeWith(baseClass, controlTable);		return baseClass;end;-- A function to register an control.function controls.Register(controlTable)	controls.m_classes[controlTable.m_sClassName] = controlTable;	return controls.m_classes[controlTable.m_sClassName];end;