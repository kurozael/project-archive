--[[	© 2011 CloudSixteen.com do not share, re-distribute or modify	this file without the permission of its owner(s).--]]util = {};util.m_rayData = {};util.m_images = {};util.m_textures = {};-- A function to convert a line to a key and value.function util.LineToKeyValue(lineData)	local exploded = string.Explode(":", lineData, nil, string.Trim);	local key, value = nil;		if ( exploded[1] ) then		key = exploded[1];	end;		if ( exploded[2] ) then		value = exploded[2];	end;		if (not key or not value) then		return key, value;	end;		local isString = string.GetBetweenTags(value, "\"");		if (isString) then		value = isString;	elseif (value == "true" or value == "false") then		value = util.ToBool(value);	else		local isArray = string.GetBetweenTags(value, "[", "]");				if (isArray) then			value = string.Explode(",", isArray, nil, tonumber);		else			value = tonumber(value);		end;	end;		return key, value;end;-- A function to convert key values to a table.function util.KeyValuesToTable(keyValues)	local bBlockComment = false;	local linesTable = string.Explode("\n", keyValues);	local retTable = {};	local block = retTable;		for k, v in ipairs(linesTable) do		if (string.sub(v, 0, 2) == "/*" and not bBlockComment) then			bBlockComment = true;		end;				if (not bBlockComment) then			local lineData = v;			local startPos, endPos = string.find(lineData, "//");						if (startPos and endPos) then				lineData = string.sub(lineData, 0, startPos - 1);			end;						if (lineData ~= "") then				local isCategory = string.GetBetweenTags(lineData, "{", "}");								if (isCategory) then					if ( not retTable[isCategory] ) then						retTable[isCategory] = {};					end;										block = retTable[isCategory];				else					local key, value = util.LineToKeyValue(lineData);										if (key and value) then						block[key] = value;					end;				end;			end;		end;				if (string.sub(v, 0, 2) == "*/" and bBlockComment) then			bBlockComment = false;		end;	end;		return retTable;end;-- A function to fix a file path (ported from C++).function util.FixFilePath(fileName, basePath, extension)	if ( not g_Files:Exists(fileName) ) then		if (string.sub( fileName, 0, string.len(basePath) ) ~= basePath) then			fileName = basePath..fileName;		end;				if (g_Files:GetExt(fileName) == "") then			fileName = fileName..extension;		end;				return fileName;	else		return fileName;	end;end;-- A function to convert text to a boolean.function util.ToBool(text)	if (text == "true") then		return true;	elseif (text == "false") then		return false;	end;end;-- A function to get a random vector.function util.RandVector()	return Vec2( math.RandomFloat(-1, 1), math.RandomFloat(-1, 1) );end;-- A function to add an accessor.function util.AddAccessor(classTable, friendlyName, keyName)	classTable["Set"..friendlyName] = function(classTable, value)		classTable[keyName] = value;	end;		classTable["Get"..friendlyName] = function(classTable)		return classTable[keyName];	end;end;-- A function to grab files in a directory.function util.GrabFilesInDir(directory, pattern, Callback)	if (not pattern) then pattern = "*"; end;		local files = {};		for k in g_Files:Scan(directory, "*") do		if ( not Callback or Callback(k) ) then			files[#files + 1] = k;		end;	end;		return files;end;-- A function to transition between two values.function util.Transition(valFrom, valTo, timeToTake, timeLeft)	return valFrom + ( ( (valTo - valFrom) / timeToTake ) * (timeToTake - timeLeft) );end;-- A function to get an image.function util.GetImage(fileName)	if ( not util.m_images[fileName] ) then		util.m_images[fileName] = g_Render:GetImage(fileName);	end;		return util.m_images[fileName];end;-- A function to get a texture.function util.GetTexture(fileName)	if ( not util.m_textures[fileName] ) then		util.m_textures[fileName] = g_Render:GetTexture(fileName);	end;		return util.m_textures[fileName];end;-- A function to get the mouse position.function util.GetMousePos()	return g_Inputs:GetMousePos()end;-- A function to convert a screen position to a world position.function util.ScreenToWorld(position, bIgnoreBounds)	if ( bIgnoreBounds or g_Camera:IsInScreenBounds(position) ) then		local cameraPos = g_Camera:GetDrawPos();		return Vec2(cameraPos.x + position.x, cameraPos.y + position.y);	end;end;-- A function to convert an angle to a vector.function util.AngleToVector(angle)	if (type(angle) ~= "number") then		local radians = angle:Radians();		return Vec2( math.cos(radians), math.sin(radians) );	else		return Vec2( math.cos(angle), math.sin(angle) );	end;end;-- A function to normalize a vector.function util.NormalizeVector(vector)	local length = vector:Length();		return Vec2(		vector.x / length,		vector.y / length	);end;-- A function to get the angle between two vectors.function util.AngleBetweenVectors(vecOne, vecTwo)	return util.Radians( math.atan2(vecTwo.y - vecOne.y, vecTwo.x - vecOne.x) );end;-- A function to get whether a vector is empty.function util.IsEmptyVector(vector)	return (vector.x == 0 and vector.y == 0);end;-- A function to get the size of some text.function util.GetTextSize(fontName, text)	return g_Fonts:GetFont(fontName):GetTextSize(text);end;-- A function to make blood particles at a position.function util.MakeBloodParticles(position, color, scale)	if (not color) then color = Color(0.8, 0.1, 0.1, 0.7); end;	if (not scale) then scale = 1; end;		local emitter = emitters.New(position);		for i = 1, 8 do			local particle = emitter:Add( "particles/simple", Vec2(0, 0) );						particle:SetKillTime( math.random(1, 3) );			particle:SetStartSize(math.random(16, 32) * scale);			particle:SetEndSize(math.random(8, 16) * scale);			particle:SetVelocity( util.RandVector() * math.random(64, 128) );			particle:SetColor(color);		end;	emitter:Dispatch();end;-- A function to get the furthest vector.function util.GetFurthestVector(position, ...)	local positions = {...};	local furthest = {};		for k, v in ipairs(positions) do		local distance = v:Distance(position);				if (not furthest.vector or distance > furthest.distance) then			furthest.distance = distance;			furthest.vector = v;		end;	end;		return furthest.vector;end;-- A function to get the closest entity to another entity.function util.GetClosestEntity(entity, className, Condition)	local entityList = nil;		if (type(className) ~= "table") then		entityList = entities.GetByClassName(className);	else		entityList = className;	end;		local position = entity:GetCenter();	local closest = {};		for k, v in ipairs(entityList) do		if ( entity ~= v and ( not Condition or Condition(v) ) ) then			local distance = v:GetCenter():Distance(position);						if (not closest.entity or distance < closest.distance) then				closest.distance = distance;				closest.entity = v;			end;		end;	end;		return closest.entity, closest.distance;end;-- A function to get the ray data.function util.GetTraceData()	return util.m_rayData;end;-- A function to perform cast a ray.function util.RayCast(startPos, endPos, filter, Condition)	if (type(filter) ~= "table") then		filter = {filter};	end;		util.m_rayData = {		Condition = Condition;		results = {			hitMaterial = MAT_GENERIC,			hitEntity = nil,			startPos = startPos,			distance = startPos:Distance(endPos),			fraction = 0,			endPos = endPos,			hitPos = endPos,			didHit = false		},		filter = filter;	};		g_Physics:RayCast(startPos, endPos);		local results = util.m_rayData.results;		util.m_rayData = nil;	return results;end;-- A function to create a rectangle.function util.Rectangle(x, y, w, h)	return {		x = x,		y = y,		w = w,		h = h	};end;-- A function to snap a position to a grid.function util.SnapToGrid(position, gridSize)	if (type(position) ~= "number") then		return Vec2(			util.SnapToGrid(position.x, gridSize),			util.SnapToGrid(position.y, gridSize)		);	else		local dividedSize = position / gridSize;				if ( math.abs(math.floor(dividedSize) - dividedSize)		< math.abs(math.ceil(dividedSize) - dividedSize) ) then			return math.floor(position / gridSize) * gridSize;		else			return math.ceil(position / gridSize) * gridSize;		end;	end;end;-- A function to get whether a position is inside a rectangle.function util.IsInside(rectangle, position)	return (position.x > rectangle.x and position.y > rectangle.y		and position.x < rectangle.x + rectangle.w		and position.y < rectangle.y + rectangle.h);end;-- A function to get whether a rectangle overlaps another rectangle.function util.DoesOverlap(rectangleA, rectangleB)	return (rectangleA.x + rectangleA.w > rectangleB.x		and rectangleA.y + rectangleA.h > rectangleB.y		and rectangleB.x + rectangleB.w > rectangleA.x		and rectangleB.y + rectangleB.h > rectangleA.y);end;-- A function to get the distance from a line to a position.function util.LineToPosDist(lineStart, lineEnd, position)	local m = lineEnd - lineStart;	local t = m:Dot(position - lineStart) / m:Dot(m);		return ( lineStart + (m * t) ):Distance(position)end;-- A function to get any point on a line.function util.GetPointOnLine(lineStart, lineEnd, t)	return lineStart + ( (lineEnd - lineStart) * t );end;-- A function to get the name of a file with no extension.function util.FileNameNoExt(fileName)	local extension = g_Files:GetExt(fileName);		if (extension ~= "") then		return g_Files:GetName( string.sub( fileName, 0, -(string.len(extension) + 2) ) );	else		return g_Files:GetName(fileName);	end;end;-- A function to get whether a file name is an image.function util.IsImage(fileName)	local extension = g_Files:GetExt(fileName);	return (extension == "png" or extension == "gif" or extension == "jpg");end;-- A function to get whether a file name is a directory.function util.IsDirectory(fileName)	if (string.sub(fileName, -1) == "/" or g_Files:GetExt(fileName) == "") then		return true;	else		return false;	end;end;-- A function to get a new angle object in degrees.function util.Degrees(degrees)	return Angle(degrees, ANGLE_DEGREES);end;-- A function to get a new angle object in radians.function util.Radians(radians)	return Angle(radians, ANGLE_RADIANS);end;